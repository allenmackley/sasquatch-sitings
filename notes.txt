* Use Node.js, Express, GraphQL, Apollo, and MySQL

Endpoints:
/graphql

Everything will be accessible through the one, GraphQL endpoint, and the flexibility for the different CRUD functions will be provided through the GraphQL resolvers.

Tables:

siting
    id            unsigned INT PRIMARY KEY AUTO INCREMENT
    latitude      signed FLOAT 9,6
    longitude     signed FLOAT 9,6
    time          DATETIME
    description   TEXT
tags
    id            unsigned INT PRIMARY KEY AUTO INCREMENT
    siting_id     unsigned INT (foreign key index)
    name          VARCHAR(50)

Sample Data Format: Tab Separated Values
Description - Latitude - Longitude - Time - Tags

Use MySQL 8 and new Geo Information Systems (GIS)
Shouldn't need a separate library to help, because MySQL 8 should already have all functions needed
https://www.youtube.com/watch?v=V8LNyiBACLo

Use Node MySQL with connection pooling
https://github.com/mysqljs/mysql

Will need to use Google and JavaScript Geolocation APIs to help.

This assessment is actually slightly simpler than the one I did before. Refer to my earlier project to use as a guide, but re-write it new. I can, however, copy most of the docker-compose files from before to save a lot of time on that portion.

What will be new about the assessment this time:
I will use GraphQL instead of REST (Because now I know it, Yay!)

Also, I will make sure to fix the following problems from my last assessment, based on feedback:
* Initialize the database in a separate file
* Use some sort of connection pooling
* Break app.js out into smaller classes, use one file per class

Feedback from last assessment:
"Great job recognizing the many to many relationship between classes and teachers. Also great job on implementing a Person entity with students and teachers having a person_id. This does allow for flexibility and normalization. Generally it's good practice to initialize your database in a separate file (So that it can be reused if needed and you can group database helper functions together for high cohesiveness) and to use connection pooling. app.js should have been broken out into smaller classes. Generally it is good to break up each resource into their own class to make the code more readable and organizable which results in more maintainable code."